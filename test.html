<!DOCTYPE html>

<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!--<link rel="stylesheet" type="text/css" href="" />-->
  <style>
    body {
      color: #fefefe;
      background: #020202;
    }
  </style>
  
  <!-- web fonts -->
  <!--<link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">-->
  
  <!-- OpenGL utilities -->
  <script type="text/javascript" src="twgl.min.js"></script>
  <!--<script type="text/javascript" src="gl-matrix-min.js"></script>-->
  
  <!-- shaders -->
  
  <script id="pass-vert" type="text/plain">
    #version 300 es
    
    // inputs
    in vec4 position;
    
    void main() {
      gl_Position = position;
    }
  </script>
  
  <script id="test-frag" type="text/plain">
    #version 300 es
    
    precision highp float;
    
    // outputs
    out vec4 fragColor;
    
    // resolution
    uniform vec2 resolution;
    uniform float shortdim;
    uniform float dpr;
    
    // triangulation
    uniform int next_edge[512];
    uniform float half_shear[128];
    uniform int n_edges;
    
    // left and right turns
    const mat4 left = mat4(
       1.,  0., 0., 0.,
       0.,  1., 0., 0.,
      -1.,  0., 1., 0.,
       0., -1., 0., 1.
    );
    const mat4 right = mat4(
      1., 0., -1.,  0.,
      0., 1.,  0., -1.,
      0., 0.,  1.,  0.,
      0., 0.,  0.,  1.
    );
    
    void main() {
      // the isometries that send the sides of the base triangle to the geoesic
      // from 0 to infinity in the upper half-plane
      mat4 stem[3];
      const float h = 0.5*sqrt(3.);
      stem[0] = mat4(
         1.,  0., -0.5,    h,
         0.,  1.,   -h, -0.5,
        -1.,  0.,  0.5,    h,
         0., -1.,   -h,  0.5
      );
      stem[1] = mat4(
        -0.5,   -h,  1.,  0.,
           h, -0.5,  0.,  1.,
         -1.,   0., 0.5,   h,
          0.,  -1.,   h, 0.5
      );
      stem[2] = mat4(
        -0.5,   -h,  1.,  0.,
           h, -0.5,  0.,  1.,
         0.5,   -h, -1.,  0.,
           h,  0.5,  0., -1.
      );
      
      // triangle walk
      vec2 z = (2.*gl_FragCoord.xy - resolution) / shortdim;
      if (dot(z, z) < 1.) {
        // departure
        vec4 u = vec4(z, 1., 0.);
        vec4 v;
        int edge = -1;
        int first_edge; /* for test coloring */
        vec3 color = vec3(0.9, 0.9, 1.);
        for (int k = 0; k < 3; k++) {
          v = stem[k] * u;
          if (dot(v.xy, v.zw) > 0.) {
            edge = k;
            first_edge = k; /* for test coloring */
            break;
          }
        }
        if (edge < 0) {
          fragColor = vec4(1.);
          return;
        }
        
        // later steps
        for (int step = 0; step < 18; step++) {
          float x = half_shear[edge % n_edges];
          v *= vec4(vec2(1./x), vec2(x));
          if (dot(v.xy, v.zw) > dot(v.zw, v.zw)) {
            v = left * v;
            edge = next_edge[2*edge];
            color.r *= 0.8;
          } else if (dot(v.zw, v.xy) > dot(v.xy, v.xy)) {
            v = right * v;
            edge = next_edge[2*edge+1];
            color.g *= 0.8;
          } else {
            break;
          }
        }
        for (int k = 0; k < first_edge; k++) color = color.gbr;
        fragColor = vec4(color, 1.);
      } else {
        fragColor = vec4(0.);
      }
    }
  </script>
  
  <title>Hormonica</title>
</head>

<body>
  <div>
    <a onclick="flip(3)">flip 3</a> |
    <a onclick="flip(4)">flip 4</a> |
    <a onclick="flip(5)">flip 5</a>
  </div>
  <canvas id="test" width="750" height="750"></canvas>
  
  <script>
    // --- get canvases and hook up interactions ---
    
    testCanvas = document.querySelector('#test');
    
    // --- initialize shaders ---
    
    const arrays = {
      position: [
        // northwest triangle
        -1, -1, 0,
        -1,  1, 0,
         1,  1, 0,
        // southeast triangle
        -1, -1, 0,
         1,  1, 0,
         1, -1, 0
      ]
    };
    
    var ctx = testCanvas.getContext('webgl2');
    var programInfo = twgl.createProgramInfo(ctx, ['pass-vert', 'test-frag']);
    var bufferInfo = twgl.createBufferInfoFromArrays(ctx, arrays);
    
    // triangulation and shear coordinates
    half_shear = [7/6, 9/7, 6/9, 6/9, 7/6, 9/7]
    next_edge = [
      3, 5+6,
      4, 3+6,
      5, 4+6,
      1+6, 4,
      2+6, 5,
      0+6, 3,
      2, 1,
      0, 2,
      1, 0,
      5+6, 0+6,
      3+6, 1+6,
      4+6, 2+6
    ]
    n_edges = half_shear.length
    
    function left(edge) {
      return next_edge[2*edge];
    }
    
    function right(edge) {
      return next_edge[2*edge+1];
    }
    
    function inv(edge) {
      return (edge + n_edges) % (2*n_edges);
    }
    
    function flip(edge) {
      // get relevant edges
      edge_inv = inv(edge);
      nigh = [right(edge), left(edge), right(edge_inv), left(edge_inv)];
      nigh_inv = nigh.map(inv);
      
      // find new shear coordinates
      half_shear_edge_old = half_shear[edge % n_edges];
      half_shear_edge_new = 1 / half_shear_edge_old;
      shear_edge_old = half_shear_edge_old * half_shear_edge_old;
      half_shear_even_mult = Math.sqrt(1 + shear_edge_old);
      half_shear_odd_mult = Math.sqrt(1 / (1 + 1 /shear_edge_old));
      
      // update shear coordinates
      half_shear[edge % n_edges] = half_shear_edge_new;
      half_shear[nigh[0] % n_edges] *= half_shear_even_mult;
      half_shear[nigh[1] % n_edges] *= half_shear_odd_mult;
      half_shear[nigh[2] % n_edges] *= half_shear_even_mult;
      half_shear[nigh[3] % n_edges] *= half_shear_odd_mult;
      
      // update paths out of quadrilateral
      next_edge[2*edge+1] = nigh[1];
      next_edge[2*edge] = nigh[2];
      next_edge[2*edge_inv+1] = nigh[3];
      next_edge[2*edge_inv] = nigh[0];
      
      // update paths into quadrilateral
      next_edge[2*nigh_inv[0]] = nigh[3];
      next_edge[2*nigh_inv[0]+1] = edge;
      next_edge[2*nigh_inv[1]] = edge_inv;
      next_edge[2*nigh_inv[1]+1] = nigh[2];
      next_edge[2*nigh_inv[2]] = nigh[1];
      next_edge[2*nigh_inv[2]+1] = edge_inv;
      next_edge[2*nigh_inv[3]] = edge;
      next_edge[2*nigh_inv[3]+1] = nigh[0];
    }
    
    // --- define rendering routine ---
    
    function render(time) {
      // size canvas
      twgl.resizeCanvasToDisplaySize(testCanvas);
      
      // paint canvas
      ctx.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(ctx, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, {
        resolution: [ctx.canvas.width, ctx.canvas.height],
        shortdim: Math.min(ctx.canvas.width, ctx.canvas.height),
        dpr: window.devicePixelRatio,
        half_shear: half_shear,
        next_edge: next_edge,
        n_edges: 6
      });
      twgl.drawBufferInfo(ctx, bufferInfo);
      
      // request next frame
      requestAnimationFrame(render);
    }
    
    // kick off animation
    requestAnimationFrame(render);
  </script>
</body>
</html>

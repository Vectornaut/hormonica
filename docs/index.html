<!DOCTYPE html>

<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!--<link rel="stylesheet" type="text/css" href="" />-->
  <style>
    body {
      color: #c0c0c0;
      background-color: #202020;
      font-family: sans-serif;
    }
    
    .control-bar {
      display: flex;
      margin-bottom: 6px;
    }
    
    .control {
      margin: 0 12px 0 0;
      display: flex;
      align-items: center;
    }
    
    .control > input:not(:first-child) {
      margin-left: 6px;
    }
    
    .control > label:not(:first-child) {
      margin-left: 6px;
    }
    
    /*
     formatting tips from Stephanie Eckles
     https://moderncss.dev/custom-css-styles-for-form-inputs-and-textareas/
    */
    input {
      background-color: #020202;
      border: 1px solid hsl(0, 0%, 30%);
      border-radius: 4px;
      color: #c0c0c0;
      font-size: inherit;
    }
    
    input[type=button]:hover {
      background-color: #303030;
    }
    
    input[type=button]:active, input[type=button].pressed {
      color: white;
      background-color: #404040;
      border-color: hsl(0, 0%, 40%);
    }
    
    input[type=button]:disabled {
      filter: brightness(0.5);
      /* colors adjusted to compensave for filter */
      background-color: #404040;
      border-color: hsl(0, 0%, 60%);
    }
  </style>
  
  <!-- web fonts -->
  <!--<link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">-->
  
  <!-- OpenGL utilities -->
  <script type="text/javascript" src="twgl.min.js"></script>
  <script type="text/javascript" src="gl-matrix-min.js"></script>
  
  <!-- shaders -->
  
  <script id="pass-vert" type="text/plain">
    #version 300 es
    
    // inputs
    in vec4 position;
    
    void main() {
      gl_Position = position;
    }
  </script>
  
  <script id="test-frag" type="text/plain">
    #version 300 es
    
    precision highp float;
    
    // outputs
    out vec4 fragColor;
    
    // resolution
    uniform vec2 resolution;
    uniform float shortdim;
    uniform float dpr;
    
    // triangulation
    uniform int next_edge[512];
    uniform float half_shear[128];
    uniform vec3 edge_color[128];
    uniform int n_edges;
    
    // viewpoint
    uniform int ref_edge;
    uniform mat4 unframe;
    
    // --- pixel sampling ---
    
    const float A1 = 0.278393;
    const float A2 = 0.230389;
    const float A3 = 0.000972;
    const float A4 = 0.078108;
    
    // Abramowitz and Stegun, equation 7.1.27
    float erfc_appx(float t) {
      float r = abs(t);
      float p = 1. + A1*(r + A2*(r + A3*(r + A4*r)));
      float p_sq = p*p;
      float erfc_r = 1. / (p_sq*p_sq);
      return t < 0. ? (2. - erfc_r) : erfc_r;
    }
    
    // how much of a pixel's sampling distribution falls on a thickened line.
    // `width` is the line thickness, in pixels. `pattern_disp` is the pixel's
    // displacement from the line in pattern space
    float line_part(float width, float pattern_disp, float scaling, float r_px) {
      // find the displacement to the edge in the screen tangent space
      float screen_disp = pattern_disp / scaling;
      float screen_disp_px = screen_disp / r_px;
      
      // integrate our pixel's sampling distribution on the screen tangent space to
      // find out how much of the pixel falls within `width/2` of the line
      float lower = erfc_appx(screen_disp_px - 0.5*width);
      float upper = erfc_appx(screen_disp_px + 0.5*width);
      return 0.5*(lower - upper);
    }
    
    vec3 line_mix(vec3 stroke, vec3 bg, float width, float pattern_disp, float scaling, float r_px) {
      return mix(bg, stroke, line_part(width, pattern_disp, scaling, r_px));
    }
    
    vec4 line_mix(vec4 stroke, vec4 bg, float width, float pattern_disp, float scaling, float r_px) {
      return mix(bg, stroke, line_part(width, pattern_disp, scaling, r_px));
    }
    
    // --- triangle walk ---
    
    // left and right turns
    const mat4 left = mat4(
      1., 0., -1.,  0.,
      0., 1.,  0., -1.,
      0., 0.,  1.,  0.,
      0., 0.,  0.,  1.
    );
    const mat4 right = mat4(
       1.,  0., 0., 0.,
       0.,  1., 0., 0.,
      -1.,  0., 1., 0.,
       0., -1., 0., 1.
    );
    
    // display parameters
    const float view = 1.02;
    const vec3 bg_color = vec3(1./128.);
    
    void main() {
      // the mobius transformation that maps the unit disk to the upper half-
      // plane, fixing 1 and -1
      const mat4 unroll = 1./sqrt(2.) * mat4(
         0., 1.,  1., 0.,
        -1., 0.,  0., 1.,
         1., 0.,  0., 1.,
         0., 1., -1., 0.
      );
      
      // the mobius transformation that gives the upper half-plane a half-turn
      // around `i`
      const mat4 half_turn = mat4(
        0., 0., -1.,  0.,
        0., 0.,  0., -1.,
        1., 0.,  0.,  0.,
        0., 1.,  0.,  0.
      );
      
      // project from the screen to the Poincare disk
      float r_px = view / shortdim; // the inner radius of a pixel in the Euclidean metric of the screen
      vec2 z = r_px * (2.*gl_FragCoord.xy - resolution);
      float r_sq = dot(z, z);
      float proj_scaling = 2. / (1.-r_sq); // the conformal scale factor of the projection
      
      // triangle walk
      if (r_sq < 1.) {
        // departure
        vec4 v = unframe * unroll * vec4(z, 1., 0.);
        int edge = ref_edge;
        if (dot(v.xy, v.zw) < 0.) {
          v = half_turn * v;
          edge = (edge + 6) % (2*n_edges);
        }
        
        // during the walk, we'll use these to see whether we're beyond the left
        // and right sides of the triangle. when we arrive, we'll use them
        // to find the signed distances to the sides of the triangle
        float m; // Re(ab')
        float q_a; // |a|^2
        float q_b; // |b|^2
        
        // `t_side := tanh(d_side)`, where `d_side` is the distance to a side
        // of the triangle
        float t_base;
        float t_left;
        float t_right;
        
        // color sampling
        vec4 fg_color = vec4(0.);
        float fg_alpha = 0.;
        vec3 blur_color = vec3(0.);
        float blur_samples = 0.;
        
        // later steps
        int step; /* for reference edge marking */
        const int step_max = 40;
        for (/*int*/ step = 0; step < step_max; step++) {
          // shear the opposite vertex to 1
          if (step > 0 || edge != ref_edge) {
            float x = half_shear[edge % n_edges];
            v *= vec4(vec2(1./x), vec2(x));
          }
          
          // set up to find the signed distances to the left and right sides.
          // we look at `v` as a pair `(a, b)` of complex numbers
          m = dot(v.xy, v.zw); // Re(ab')
          q_a = dot(v.xy, v.xy); // |a|^2
          q_b = dot(v.zw, v.zw); // |b|^2
          
          // the base side of the triangle is the geodesic from 0 to infinity
          // in the upper half-plane. the curve through `v` which is
          // equidistant from the base side is a ray which leaves 0 at some
          // angle `phi`. the distance `d_base` from `v` to the base side is
          // given by (Series, "Hyperbolic Geometry: MA 448", section 2.2.7)
          //
          //   t_base := tanh(d_base) = cos(phi)
          //
          float t_base = m / sqrt(q_a * q_b);
          
          // area-sample the edge
          if (abs(t_base) < 16.*(proj_scaling * r_px)) {
            vec4 mix = line_mix(vec4(edge_color[edge % n_edges], 1.), vec4(0.), 4., t_base, proj_scaling, r_px);
            fg_color += mix;
            fg_alpha = max(mix.a, fg_alpha);
            blur_color += line_mix(edge_color[edge % n_edges], bg_color, 4., 0., proj_scaling, r_px);
            blur_samples += 1.;
          }
          
          if (m > q_a) {
            v = left * v;
            edge = next_edge[2*edge];
          } else if (m > q_b) {
            v = right * v;
            edge = next_edge[2*edge+1];
          } else {
            break;
          }
        }
        
        // --- arrival ---
        
        // find the hyperbolic tangents of the distances to the left and right
        // sides
        float diff = sqrt(dot(v.xy - v.zw, v.xy - v.zw)); // |a - b|
        t_left = (m - q_a) / (sqrt(q_a) * diff);
        t_right = (m - q_b) / (sqrt(q_b) * diff);
        
        // find the nearest edge
        float t_near = t_base;
        int near_edge = edge;
        if (-t_left < abs(t_near)) {
          t_near = t_left;
          near_edge = next_edge[2*edge];
        }
        if (-t_right < abs(t_near)) {
          t_near = t_right;
          near_edge = next_edge[2*edge+1];
        }
        
        // find the conformal scale factor of the Poincare projection
        float proj_scaling = 2. / (1.-r_sq);
        
        /* mark the reference edge */
        vec3 color = bg_color;
        if (step == 0 && edge == ref_edge) {
          color = mix(color, edge_color[ref_edge % n_edges], 0.4*exp(-3.*m * (exp(-3.*q_a) + exp(-3.*q_b)) / (q_a*exp(-3.*q_a) + q_b*exp(-3.*q_b))));
        }
        
        // area-sample the left and right edges
        if (abs(t_left) < 16.*(proj_scaling * r_px)) {
          int left_edge = next_edge[2*edge];
          vec4 mix = line_mix(vec4(edge_color[left_edge % n_edges], 1.), vec4(0.), 4., t_left, proj_scaling, r_px);
          fg_color += mix;
          fg_alpha = max(mix.a, fg_alpha);
        }
        if (abs(t_right) < 16.*(proj_scaling * r_px)) {
          int right_edge = next_edge[2*edge+1];
          vec4 mix = line_mix(vec4(edge_color[right_edge % n_edges], 1.), vec4(0.), 4., t_right, proj_scaling, r_px);
          fg_color += mix;
          fg_alpha = max(mix.a, fg_alpha);
        }
        if (step >= step_max) {
          color = blur_color / blur_samples;
        } else {
          if (fg_alpha > 0.) fg_color /= fg_color.a;
          color = mix(color, fg_color.rgb, fg_alpha);
        }
        
        // area-sample the disk boundary
        color = line_mix(bg_color, color, 2., r_sq - 1., 2., r_px);
        fragColor = vec4(color, 1.);
      } else {
        fragColor = line_mix(vec4(bg_color, 1.), vec4(0.), 2., r_sq - 1., 2., r_px);
      }
    }
  </script>
  
  <title>Hormonica</title>
</head>

<body>
  <div class="control-bar">
    <div class="control">
      <label>change reference edge:</label>
      <input type="button" onclick="slither_ref_edge_left()" value="left"/>
      <input type="button" onclick="slither_ref_edge_right()" value="right"/>
      <input type="button" onclick="reverse_ref_edge()" value="reverse"/>
    </div>
  </div>
  <div class="control-bar">
    <div class="control">
      <input type="button" onclick="flip(0)" style="color: #ff0080" id="flip0" value="flip 0"/>
      <input type="button" onclick="flip(1)" style="color: #ff8000" id="flip1" value="flip 1"/>
      <input type="button" onclick="flip(2)" style="color: #ffff00" id="flip2" value="flip 2"/>
      <input type="button" onclick="flip(3)" style="color: #00ff00" id="flip3" value="flip 3"/>
      <input type="button" onclick="flip(4)" style="color: #0080ff" id="flip4" value="flip 4"/>
      <input type="button" onclick="flip(5)" style="color: #8000ff" id="flip5" value="flip 5"/>
    </div>
  </div>
  <canvas id="test" width="650" height="650"></canvas>
  
  <script>
    var mat4 = glMatrix.mat4;
    
    // --- get canvases and hook up interactions ---
    
    var testCanvas = document.querySelector('#test');
    
    // --- initialize shaders ---
    
    const arrays = {
      position: [
        // northwest triangle
        -1, -1, 0,
        -1,  1, 0,
         1,  1, 0,
        // southeast triangle
        -1, -1, 0,
         1,  1, 0,
         1, -1, 0
      ]
    };
    
    var ctx = testCanvas.getContext('webgl2');
    var programInfo = twgl.createProgramInfo(ctx, ['pass-vert', 'test-frag']);
    var bufferInfo = twgl.createBufferInfoFromArrays(ctx, arrays);
    
    // triangulation and shear coordinates
    var half_shear = [7/6, 9/7, 6/9, 6/9, 7/6, 9/7]
    var next_edge = [
      3, 5+6,
      4, 3+6,
      5, 4+6,
      1+6, 4,
      2+6, 5,
      0+6, 3,
      2, 1,
      0, 2,
      1, 0,
      5+6, 0+6,
      3+6, 1+6,
      4+6, 2+6
    ]
    var edge_color = [
      1.0, 0.0, 0.5,
      1.0, 0.5, 0.0,
      1.0, 1.0, 0.0,
      0.0, 1.0, 0.0,
      0.0, 0.5, 1.0,
      0.5, 0.0, 1.0
    ]
    var n_edges = half_shear.length
    
    // viewpoint
    var ref_edge = 0;
    {
      let x = Math.sqrt(half_shear[ref_edge]);
      var unframe = mat4.fromValues(
        1/x,   0, 0, 0,
        0,   1/x, 0, 0,
        0,     0, x, 0,
        0,     0, 0, x
      );
      /*var unframe = mat4.create();
      mat4.identity(unframe);*/
    }
    
    function left(edge) {
      return next_edge[2*edge];
    }
    
    function right(edge) {
      return next_edge[2*edge+1];
    }
    
    function inv(edge) {
      return (edge + n_edges) % (2*n_edges);
    }
    
    function reverse_ref_edge() {
      ref_edge = inv(ref_edge);
      let x = half_shear[ref_edge % n_edges];
      mat4.multiply(
        unframe,
        mat4.fromValues(
            0,   0, -x,  0,
            0,   0,  0, -x,
          1/x,   0,  0,  0,
            0, 1/x,  0,  0
        ),
        unframe
      );
    }
    
    function slither_ref_edge_left() {
      ref_edge = left(ref_edge);
      let x = half_shear[ref_edge % n_edges];
      mat4.multiply(
        unframe,
        mat4.fromValues(
          1/x,   0, -x,  0,
            0, 1/x,  0, -x,
            0,   0,  x,  0,
            0,   0,  0,  x
        ),
        unframe
      );
    }
    
    function slither_ref_edge_right() {
      ref_edge = right(ref_edge);
      let x = half_shear[ref_edge % n_edges];
      mat4.multiply(
        unframe,
        mat4.fromValues(
           1/x,    0, 0, 0,
             0,  1/x, 0, 0,
          -1/x,    0, x, 0,
             0, -1/x, 0, x
        ),
        unframe
      );
    }
    
    function flip(edge) {
      // get relevant edges
      let edge_inv = inv(edge);
      let nigh = [right(edge), left(edge), right(edge_inv), left(edge_inv)];
      let nigh_inv = nigh.map(inv);
      
      // find new shear coordinates
      let half_shear_edge_old = half_shear[edge % n_edges];
      let half_shear_edge_new = 1 / half_shear_edge_old;
      let shear_edge_old = half_shear_edge_old * half_shear_edge_old;
      let half_shear_even_mult = Math.sqrt(1 / (1 + 1 / shear_edge_old));
      let half_shear_odd_mult = Math.sqrt(1 + shear_edge_old);
      
      // avoid flipping the reference edge by moving the reference edge if
      // necessary
      ref_edge_inv = inv(ref_edge);
      if ((edge - ref_edge) % n_edges == 0) {
        if (
          (left(edge) - right(edge)) % n_edges == 0 ||
          (left(edge_inv) - right(edge_inv)) % n_edges == 0
        ) {
          reverse_ref_edge();
          slither_ref_edge_left();
        } else if (
          (left(edge) - left(edge_inv)) % n_edges == 0 ||
          (left(edge) - right(edge_inv)) % n_edges == 0
        ) {
          slither_ref_edge_right();
        } else {
          slither_ref_edge_left();
        }
      }
      
      // avoid flipping an edge that the reference edge faces by moving the
      // reference edge if necessary
      ref_edge_inv = inv(ref_edge);
      if ((left(ref_edge) - edge) % n_edges == 0) {
        if (
          (left(ref_edge_inv) - edge) % n_edges == 0 ||
          (right(ref_edge_inv) - edge) % n_edges == 0
        ) {
          slither_ref_edge_right();
        } else {
          reverse_ref_edge();
        }
      }
      if ((right(ref_edge) - edge) % n_edges == 0) {
        if (
          (left(ref_edge_inv) - edge) % n_edges == 0 ||
          (right(ref_edge_inv) - edge) % n_edges == 0
        ) {
          slither_ref_edge_left();
        } else {
          reverse_ref_edge();
        }
      }
      
      // update shear coordinates
      half_shear[edge % n_edges] = half_shear_edge_new;
      half_shear[nigh[0] % n_edges] *= half_shear_even_mult;
      half_shear[nigh[1] % n_edges] *= half_shear_odd_mult;
      half_shear[nigh[2] % n_edges] *= half_shear_even_mult;
      half_shear[nigh[3] % n_edges] *= half_shear_odd_mult;
      
      // update paths out of quadrilateral
      next_edge[2*edge+1] = nigh[1];
      next_edge[2*edge] = nigh[2];
      next_edge[2*edge_inv+1] = nigh[3];
      next_edge[2*edge_inv] = nigh[0];
      
      // update paths into quadrilateral
      next_edge[2*nigh_inv[0]] = nigh[3];
      next_edge[2*nigh_inv[0]+1] = edge;
      next_edge[2*nigh_inv[1]] = edge_inv;
      next_edge[2*nigh_inv[1]+1] = nigh[2];
      next_edge[2*nigh_inv[2]] = nigh[1];
      next_edge[2*nigh_inv[2]+1] = edge_inv;
      next_edge[2*nigh_inv[3]] = edge;
      next_edge[2*nigh_inv[3]+1] = nigh[0];
      
      // disable flip buttons for self-folded edges
      for (let k = 0; k < n_edges; k++) {
        k_inv = inv(k);
        flip_button = document.querySelector('#flip' + k.toString());
        flip_button.disabled = (
          (k - left(k)) % n_edges == 0 || (k - right(k)) % n_edges == 0
        );
      }
    }
    
    // --- define rendering routine ---
    
    function render(time) {
      // size canvas
      twgl.resizeCanvasToDisplaySize(testCanvas);
      
      // paint canvas
      ctx.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(ctx, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, {
        resolution: [ctx.canvas.width, ctx.canvas.height],
        shortdim: Math.min(ctx.canvas.width, ctx.canvas.height),
        dpr: window.devicePixelRatio,
        half_shear: half_shear,
        next_edge: next_edge,
        edge_color: edge_color,
        n_edges: 6,
        ref_edge: ref_edge,
        unframe: unframe
      });
      twgl.drawBufferInfo(ctx, bufferInfo);
      
      // request next frame
      requestAnimationFrame(render);
    }
    
    // kick off animation
    requestAnimationFrame(render);
  </script>
</body>
</html>
